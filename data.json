[{"layout":"default","title":"Installation","content":"# Installation\n\n* Checkout example/minimal project.\n* Explain directory structure\n* Explain Makefile\n* Explain ardiuno-cli dependency","dir":"/1.getting-started/","name":"1.install.md","path":"1.getting-started/1.install.md","url":"/1.getting-started/1.install.html"},{"layout":"default","title":"Code","content":"# Code\nThe code below shows a minimal sketch. A minimal sketch requires to implement the *iothingy_peripherals()* method which\ninstantiates one or more peripherals. A device can have one or more peripherals connected to it. A peripheral consists\nout of one or more sensors and/or actuators that together form a conceptual thing. It contains a tiny bit of logic\nregarding how to wire the input and output. \n\nThe example below shows a device with 3 peripherals: 1 motion light detector and 2 plants. The motion light detector\nuses a standard analog peripheral. For more information about the plant peripheral have a look at the\n[Tutorial](/3.tutorial/).\n\n```c\n\n// SETTINGS\n#define DEVICE_NAME \"garden\" // A unique device name, which is part of the MQTT topic\n#define NETWORK_TYPE 1 // Network type: 0 = None, 1 = Ethernet, 2 = Wifi, 3 = ESP01\n\n// Libraries\n#include <iothingy.h>\n\n// Project specific peripherals\n#include \"./plant.h\"\n\nvoid iothingy_peripherals() {\n /**\n * Generic analog input device which can switch a output pin when a threshold\n * has been reached.\n * - Peripheral name\n * - Analog sensor pin (for example: light sensor or distance sensor)\n * - Digital output pin (for example: relay to switch a light on/off)\n * - Threshold (0-1023)\n * - Duration (ms)\n */\n analog( \"motion_light\", A0, 3, 400, 1000 );\n\n /**\n * Plant peripheral: measure moisture level and optionally control a pump.\n * - Peripheral name\n * - Moisture sensor pin\n * - Pump relay pin\n * - Threshold (0-1023)\n * - Duration (ms)\n */\n // Name Moisture Pump Threshold Duration\n plant( \"plant1\", A1, 4, 400, 1000 );\n plant( \"plant2\", A2, 5, 400, 2000 );\n}\n```\n\n","dir":"/1.getting-started/","name":"2-code.md","path":"1.getting-started/2-code.md","url":"/1.getting-started/2-code.html"},{"layout":"default","title":"Settings","content":"# Settings\nConstants can be used to define (and override) several configuration settings.\nThe software will run without any settings, but it is highly recommended to at\nleast change the device name and network type: (ethernet, wifi, esp).\n\nA typical minimal configuration contains a:\n* **DEVICE_NAME**: Used when publishing metrics to Serial and/or the MQTT\n topics. The topic name will be: *device_name/peripheral_name/metric*.\n The max length of the device name by default is 50 characters and can be\n changed with the setting: *PERIPHERAL_MAXLENGTH_DEVICE_NAME* (see the\n page [Memory Usage](/2.documentation/memory-usage.html) for more\n information).\n* **NETWORK_TYPE**: The hardware used for networking. Choose **0 = None**,\n **1 = Ethernet**, **2 = Wifi** or **3 = ESP01**. \n\n### Network\nThe **NETWORK_TYPE** setting defines if network is available and what type of\nhardware is used. In case there is a network present the following settings are\navailable to configure the network.\n```\n// SETTINGS: Network\n#define NETWORK_MAC { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED } // Mac Address.\n#define NETWORK_IP { 10, 0, 64, 192 } // IP Address. Leave undefined to use DHCP (@todo)\n#define NETWORK_DNS { 8, 8, 8, 8 } // DNS Server. Leave undefined to use DHCP (@todo)\n#define NETWORK_GW { 10, 0, 64, 1 } // Gateway. Leave undefined to use DHCP (@todo)\n\n// SETTINGS: Wifi\n#define WIFI_SSID \"YourNetworkName\"\n#define WIFI_PASSWORD \"YourNetworkPassword\"\n```\n\n### MQTT\nConfigure the settings below to publish metrics to a MQTT server. \n```\n// SETTINGS: Mqtt\n#define MQTT_SERVER { 10, 0, 64, 107 } // MQTT Server IP to connect to\n#define MQTT_PORT 1883 // MQTT Server Port\n#define MQTT_USER \"YourMqttUser\" // MQTT Username\n#define MQTT_PASSWORD \"YourMqttPassword\" // MQTT Password\n```\n\n### Serial\nThe serial port is mostly used for debugging as it should primarily communicate\nthrough MQTT.\n```\n// SETTINGS: Serial\n#define SERIAL_ENABLED 1\n#define SERIAL_BAUDRATE 115200\n```\n","dir":"/1.getting-started/","name":"3-settings.md","path":"1.getting-started/3-settings.md","url":"/1.getting-started/3-settings.html"},{"layout":"default","title":"Upload","content":"# Upload\nUse the Makefile to build, run and upload the project to a microcontroller. \n\n\n## Compiling\nRun the command below to compile the software. The output will be stored in the\nbuild directory, which will contain an executable. Modify the BOARD variable in\nthe Makefile or override it with an argument:\n```sh\nBOARD=arduino:avr:uno make build\n```\n\n## Uploading\nRun the following command to upload the compiled software to a microcontroller.\nModify the PORT variable in the Makefile or override it with an argument:\n```sh\nPORT=/dev/ttyUSB0 make upload\n```\n\n\n## Monitoring\nTo listen to the serial output run the following command. Modify the PORT and\nBAUDRATE variables or override them with an argument:\n```sh\nBAUDRATE=1155200 PORT=/dev/ttyUSB0 make monitor\n```\n","dir":"/1.getting-started/","name":"4.upload.md","path":"1.getting-started/4.upload.md","url":"/1.getting-started/4.upload.html"},{"permalink":"/1.getting-started/","layout":"default","title":"Getting started","content":"# Getting started\n\n{% include list.liquid all=true %}\n","dir":"/1.getting-started/","name":"README.md","path":"1.getting-started/README.md","url":"/1.getting-started/"},{"layout":"default","title":"Process flow","content":"# Process flow\nThe **IoThingy** framework will call a couple of methods per defined peripheral\nevery iteration. Each peripheral must have a constructor method. Next the\nframework will call the *&lt;name&gt;_read_input_pins*, *&lt;name&gt;_set_output_pins*,\n*&lt;name&gt;_parse_command and *&lt;name&gt;_publish_metrics* methods.\n\n\n## Initialisation\nDuring the initialisation phase the method *iothingy_peripherals()* is called\nwhich calls a constructor method for each of the defined peripherals. Every\nperipheral initializes the variables using arguments and defaults. It also must\nconfigure the mode (OUTPUT, INPUT or INPUT_PULLUP) for every pin used.\n\nRegistering a peripheral returns a slot_id which references the array element\nof the peripherals data structure. The slot_id is required for almost every\nmethod of a peripheral.\n\n```mermaid\nsequenceDiagram\n participant I as iothingy\n participant P as <name>\n participant B as peripheral\n I->>P: <name>()\n P->>B: peripheral_register()\n B->>P: slot_id (int8_t)\n P->>B: peripheral_set_pin_mode()\n```\n\n\n## Runtime\nDuring runtime the device will call the following methods for every peripheral.\nLooping the peripherals happens for every call: Meaning that first all input\npins are read, then the output will be set, parse commands and finally publish\nthe metrics.\n\n```mermaid\nsequenceDiagram\n participant I as iothingy\n participant P as <name>\n participant B as peripheral\n I->>P: <name>_read_input_pins()\n I->>P: <name>_set_output_pins()\n I->>P: <name>_parse_command()\n I->>P: <name>_publish_metrics()\n P->>B: peripheral_publish_metric_int()\n P->>B: peripheral_publish_metric_float()\n```","dir":"/2.documentation/","name":"1.process-flow.md","path":"2.documentation/1.process-flow.md","url":"/2.documentation/1.process-flow.html"},{"layout":"default","title":"Platforms","content":"# Platforms\nIoThingy is designed to run on multiple platforms. The Makefile uses the\n[arduino-cli](https://github.com/arduino/arduino-cli) to compile and flash the\nmicro controllers. See the arduino-cli documentation for how to install board\nmanagers for other platforms, such as ESP8266.\n\n## List available platforms\n\n```\n./bin/arduino-cli board listall\nBoard Name FQBN \n4D Systems gen4 IoD Range esp8266:esp8266:gen4iod \nAdafruit Circuit Playground arduino:avr:circuitplay32u4cat \nAdafruit Circuit Playground Express arduino:samd:adafruit_circuitplayground_m0 \nAdafruit Feather HUZZAH ESP8266 esp8266:esp8266:huzzah \nAmperka WiFi Slot esp8266:esp8266:wifi_slot \nArduino Duemilanove or Diecimila arduino:avr:diecimila \nArduino Ethernet arduino:avr:ethernet \nArduino Mega or Mega 2560 arduino:avr:mega \nArduino Nano arduino:avr:nano \nArduino Uno arduino:avr:uno \nArduino Uno WiFi arduino:avr:unowifi \nArduino Uno WiFi Rev2 arduino:megaavr:uno2018 \nNodeMCU 0.9 (ESP-12 Module) esp8266:esp8266:nodemcu \nNodeMCU 1.0 (ESP-12E Module) esp8266:esp8266:nodemcuv2 \nSparkFun Blynk Board esp8266:esp8266:blynk \nSparkFun ESP8266 Thing esp8266:esp8266:thing \nSparkFun ESP8266 Thing Dev esp8266:esp8266:thingdev \n```\n\n## Compile and flash for specific platform\nThe software can be compiled and uploaded for a specific platform by using the\nBOARD argument. Choose a valid platform from the output of the command listed\nabove.\n\nAnother way is to update the Makefile and modify the BOARD variable, so it uses\nthat platform by default.\n```\nBOARD=arduino:megaavr:uno2018 make build\nBOARD=arduino:megaavr:uno2018 make upload\n```\n\n\n## Different constraints\nDifferent platforms have different constraits especially in regards to memory.\nA standard arduino has 2Kb SRAM, 1Kb EEPROM and 32Kb Flash memory. The memory\nthat will be reserved for the peripherals need to fit into the available RAM,\nwhile it also needs to leave some space available for the stack. \n\nThe number of peripherals (and thus the amount of memory allocated) can be \nconfigured using serveral constants. Keep in mind that if you tighten those\nsettings to tight it might lead to unknown behaviour when it runs out of\nmemory. For more information see the next section regarding\n[Memory usage](/2.documentation/memory-usage.html).","dir":"/2.documentation/","name":"2.platforms.md","path":"2.documentation/2.platforms.md","url":"/2.documentation/2.platforms.html"},{"layout":"default","title":"Memory usage","content":"# Memory usage\nMemory is allocated for every peripheral slot. By default a peripheral has 8\nsimple variables (int8_t), 4 complex variables (struct of int32_t, float or\nbool) and 2 timers variables (unsigned long). These variables can be used to\nstore input/output pins, its current state and other parameters.\n\nMemory in micro controllers is often scarce. The following settings can be used\nto alter the memory footprint of the peripheral data structure.\n\n* **PERIPHERAL_MAXLENGTH_DEVICE**: The max length of a device name in bytes.\n* **PERIPHERAL_MAXLENGTH_NAME**: The max length of a peripheral name in bytes.\n* **PERIPHERAL_MAXSIZE**: Number of peripherals.\n\n","dir":"/2.documentation/","name":"3.memory-usage.md","path":"2.documentation/3.memory-usage.md","url":"/2.documentation/3.memory-usage.html"},{"permalink":"/2.documentation/","layout":"default","title":"Documentation","content":"# Documentation\n\n{% include list.liquid all=true %}\n","dir":"/2.documentation/","name":"README.md","path":"2.documentation/README.md","url":"/2.documentation/"},{"layout":"default","title":"Controlling actuators","content":"# Controlling actuators\n\n\n## Constructor\nThe plant peripheral can be also instantiated with a second argument with the\npin number of a relay to control the pump. Also the threshold and timer can be\nset during instantiation with the various constructors.\n\n```c\n\n/**\n * Instantiate a plant peripheral with an analog input pin to measure the\n * moisture level and and digital output pin to control a pump.\n */\nint8_t plant( char name[], uint8_t moisture_pin, uint8_t pump_pin ) {\n // Get free peripheral slot\n int8_t slot = peripheral_register( name, TYPE_PLANT );\n if( slot < 0 ) {\n return -1;\n }\n\n plant_set_defaults( slot );\n plant_set_moisture_pin( slot, moisture_pin );\n plant_set_pump_pin( slot, pump_pin );\n serial_display_memory_usage();\n\n return slot;\n}\n\n\n/**\n * Instantiate a plant peripheral with an analog input pin to measure the\n * moisture level, digital output pin to control a pump and a threshold.\n */\nint8_t plant( char name[], uint8_t moisture_pin, uint8_t pump_pin, uint32_t threshold ) {\n // Get free peripheral slot\n int8_t slot = peripheral_register( name, TYPE_PLANT );\n if( slot < 0 ) {\n return -1;\n }\n\n plant_set_defaults( slot );\n plant_set_moisture_pin( slot, moisture_pin );\n plant_set_pump_pin( slot, pump_pin );\n plant_set_threshold( slot, threshold );\n serial_display_memory_usage();\n\n return slot;\n}\n\n\nvoid plant_set_defaults( uint8_t slot ) { \n // Plant specific: Moisture threshold & pump duration\n peripherals[ slot ].val01.i = PLANT_MOISTURE_THRESHOLD;\n}\n\n\nvoid plant_set_pump_pin( uint8_t slot, uint8_t pump_pin ) {\n SERIAL_DEBUG_S(F(\"- pump pin: \"));\n SERIAL_DEBUG_I(pump_pin);\n SERIAL_DEBUG_S(F(\"\\n\"));\n peripherals[ slot ].pin02 = pump_pin;\n peripheral_set_pin_mode( peripherals[slot].pin02, OUTPUT );\n}\n\n\nvoid plant_set_threshold( uint8_t slot, uint32_t threshold ) {\n SERIAL_DEBUG_S(F(\"- threshold: \"));\n SERIAL_DEBUG_I(threshold);\n SERIAL_DEBUG_S(F(\"\\n\"));\n peripherals[ slot ].val01.i = threshold;\n}\n```\n\n## Setting output pins\nBased on the sensor value read in step 1 we want to compare it with a threshold\nto decide if we need to enable the pump or not. Implement a method with the\nname *&lt;name&gt;_set_output_pins* which changes the state of the output pins\nbased on the stored values and sensor readings.\n```c\n\n/**\n * Output the stored value to the output pin(s) with the specified mode(s).\n */\nvoid plant_set_output_pins( uint8_t slot ) {\n bool thresholdReached = peripherals[ slot ].val03.i > peripherals[ slot ].val01.i;\n bool setPumpOn = false;\n\n if( thresholdReached ) {\n setPumpOn = true;\n SERIAL_DEBUG_S(F(\"- threshold reached => enable pump\\n\"));\n peripherals[ slot ].timer01 = millis();\n\n } else {\n // Default off\n setPumpOn = false;\n }\n\n // Set relay to pump on/off state.\n SERIAL_DEBUG_S(F(\"- setting pump relay to: \"));\n if( setPumpOn ) {\n digitalWrite( peripherals[ slot ].pin05, HIGH );\n digitalWrite( peripherals[ slot ].pin02, HIGH );\n SERIAL_DEBUG_S(F(\"HIGH\\n\"));\n\n } else {\n digitalWrite( peripherals[ slot ].pin05, LOW );\n digitalWrite( peripherals[ slot ].pin02, LOW );\n SERIAL_DEBUG_S(F(\"LOW\\n\"));\n }\n}\n```","dir":"/3.tutorial/","name":"2.controlling-actuators.md","path":"3.tutorial/2.controlling-actuators.md","url":"/3.tutorial/2.controlling-actuators.html"},{"layout":"default","title":"Using timers","content":"# Using timers\nThe previous step show how enable the pump whenever the moisture level reaches\na certain threshold. Sensor data often fluctuates which can cause the pump to\nstart/stop a lot of times within a short period and/or keep watering the plant\nuntil the sensor value is below the threshold. To prevent timers will be used\nto make sure that once it receives a trigger to water the plants it will enable\nthe pump for a certain amount after which it will also be disabled for a\ncertain amount. \n\n\n## Constructor\nAnother constructor will be added to set the time how long to enable the pump.\nA default value will be set for when the argument is not passed in the\nconstructor. \n```c\n\n#define PLANT_MOISTURE_THRESHOLD 567 // Analog reading between 0 and 1023\n#define PLANT_PUMP_DURATION 3 // Time (ms/100K) = 3sec\n\nvoid plant_set_defaults( uint8_t slot ) { \n // Reset timers\n peripherals[ slot ].timer01 = millis();\n peripherals[ slot ].timer02 = millis();\n\n // Plant specific: Moisture threshold & pump duration\n peripherals[ slot ].val01.i = PLANT_MOISTURE_THRESHOLD;\n peripherals[ slot ].val02.i = PLANT_PUMP_DURATION;\n}\n\n\nvoid plant_set_duration( uint8_t slot, uint32_t duration ) {\n SERIAL_DEBUG_S(F(\"- duration: \"));\n SERIAL_DEBUG_I(duration);\n SERIAL_DEBUG_S(F(\"\\n\"));\n peripherals[ slot ].val02.i = duration;\n}\n\n\n/**\n * Instantiate a plant peripheral with an analog input pin to measure the\n * moisture level, digital output pin to control a pump, threshold and\n * duration.\n */\nint8_t plant( char name[], uint8_t moisture_pin, uint8_t pump_pin, uint32_t threshold, uint32_t duration ) {\n // Get free peripheral slot\n int8_t slot = peripheral_register( name, TYPE_PLANT );\n if( slot < 0 ) {\n return -1;\n }\n\n plant_set_defaults( slot );\n plant_set_moisture_pin( slot, moisture_pin );\n plant_set_pump_pin( slot, pump_pin );\n plant_set_threshold( slot, threshold );\n plant_set_duration( slot, duration );\n serial_display_memory_usage();\n\n return slot;\n}\n```\n\n## Setting output pins\nThe logic for controlling the output pins need to be changed to deal with the\nvarious timers. Once the threshold has been reached the first timer will be set\nto the current time. Next iteration this timer will be compared to the\nduration. After the specified duration has passed another timer will be set to\ncool down the pump to prevent over watering the plant.\nIn this example the duration of the cooldown period is hard coded, but could be\nmoved to a constant or peripheral argument.\n```c\n\n/**\n * Output the stored value to the output pin(s) with the specified mode(s).\n */\nvoid plant_set_output_pins( uint8_t slot ) {\n const uint32_t COOLDOWN = 10000;\n\n bool thresholdReached = peripherals[ slot ].val03.i > peripherals[ slot ].val01.i;\n bool pumpHasStarted = millis() - peripherals[ slot ].timer01 <= peripherals[ slot ].val02.i;\n bool inCooldownPeriod = millis() - peripherals[ slot ].timer02 <= COOLDOWN;\n bool setPumpOn = false;\n\n if( inCooldownPeriod ) {\n SERIAL_DEBUG_S(F(\"- cool down period => disable pump\\n\"));\n\n } else if( pumpHasStarted ) {\n SERIAL_DEBUG_S(F(\"- keep button on => enable pump\\n\"));\n setPumpOn = true;\n peripherals[ slot ].timer02 = millis();\n\n } else if( thresholdReached ) {\n setPumpOn = true;\n SERIAL_DEBUG_S(F(\"- threshold reached => enable pump\\n\"));\n peripherals[ slot ].timer01 = millis();\n\n } else {\n // Default off\n setPumpOn = false;\n }\n\n // Set relay to pump on/off state.\n SERIAL_DEBUG_S(F(\"- setting pump relay to: \"));\n if( setPumpOn ) {\n SERIAL_DEBUG_S(F(\"HIGH\\n\"));\n digitalWrite( peripherals[ slot ].pin05, HIGH );\n digitalWrite( peripherals[ slot ].pin02, HIGH );\n\n } else {\n SERIAL_DEBUG_S(F(\"LOW\\n\"));\n digitalWrite( peripherals[ slot ].pin05, LOW );\n digitalWrite( peripherals[ slot ].pin02, LOW );\n }\n}\n```\n","dir":"/3.tutorial/","name":"3.using-timers.md","path":"3.tutorial/3.using-timers.md","url":"/3.tutorial/3.using-timers.html"},{"permalink":"/4.resources/","layout":"default","title":"Resources","content":"# Resources\n\n{% include list.liquid all=true %}\n","dir":"/4.resources/","name":"README.md","path":"4.resources/README.md","url":"/4.resources/"},{"layout":"default","title":"Peripherals","content":"# Peripherals\nBelow is a list of peripherals of known projects and libraries.\n\n* Garden\n\t* Climate\n\t* Plant\n* Modeltrain\n\t* Junction\n\t* Block\n","dir":"/4.resources/","name":"peripherals.md","path":"4.resources/peripherals.md","url":"/4.resources/peripherals.html"},{"layout":"default","title":"Projects","content":"# Projects\nThe following projects have been built using the IoThingy open source framework.\n\n## Showcase\n* [Garden](https://github.com/dirkengels/iothingy-garden)\n* [Modeltrain](https://github.com/dirkengels/iothingy-modeltrain)\n* [EPS01-DHT](https://github.com/dirkengels/iothingy-esp01-dht)\n\n## More\n* More to come (hopefully).","dir":"/4.resources/","name":"projects.md","path":"4.resources/projects.md","url":"/4.resources/projects.html"},{"permalink":"//","layout":"default","title":"IoThingy","content":"# IoThingy\nIoThingy is a framework for writing software for IoT devices. Each device\nconfigures one or more peripherals which will publish their metrics through\nMQTT and can listen for incoming commands. Multiple platforms are supported:\n[Arduino](https://arduino.cc), [ESP8622](https://www.espressif.com/en/products/socs/esp8266), [Raspberry Pi](https://www.raspberrypi.org/).\n\nTest\n","dir":"/","name":"README.md","path":"README.md","url":"/"},{"layout":"default","title":"Reading sensors","content":"# Reading sensors\n\n## Constructor\nThe constructor registers a free peripheral slot to store its arguments. The\nconstructors uses setter methods to set the invidual variables and defaults. \nThis is better than method chaining as it uses less memory of the stack\n(memory is often scarce). \n\n```c\n/**\n * Instantiate a plant peripheral with only an analog input pin to measure the\n * moisture level.\n */\nint8_t plant( char name[], uint8_t moisture_pin ) {\n // Get free peripheral slot\n int8_t slot = peripheral_register( name, TYPE_PLANT );\n if( slot < 0 ) {\n return -1;\n }\n\n plant_set_moisture_pin( slot, moisture_pin );\n return slot;\n} \n\n\nvoid plant_set_moisture_pin( uint8_t slot,uint8_t moisture_pin ) {\n SERIAL_DEBUG_S(F(\"- misture pin: \"));\n SERIAL_DEBUG_I(moisture_pin);\n SERIAL_DEBUG_S(F(\"\\n\")); \n\n peripherals[ slot ].pin01 = moisture_pin;\n peripheral_set_pin_mode( peripherals[slot].pin01, INPUT );\n}\n```\n\n## Reading input pins\nEvery iteration we want to ready the moisture level sensor and store its value.\nImplement a method with the name *&lt;name&gt;_read_input_pins*. This\nmethod should only read and store values, but not update any output pins as\nthat will be done by another method.\n```c\n/**\n * Read the pin value(s) for an analog peripheral and store it in its value.\n */\nvoid plant_read_input_pins( uint8_t slot ) {\n // Read analog input sensor.\n if( peripherals[slot].pin01 ) {\n peripherals[ slot ].val03.i = analogRead( peripherals[slot].pin01 );\n\n SERIAL_DEBUG_S(F(\"- read moisture: \"));\n SERIAL_DEBUG_I( peripherals[ slot ].val03.i );\n SERIAL_DEBUG_S(F(\"\\n\"));\n }\n}\n```\n\n\n## Publishing metrics\nReading the value from a sensor is useless unless you do something with it. In\nmost cases you want to publish the value of this sensor to a MQTT topic. \nImplement a method with the name *&lt;name&gt;_publish_metrics*. This\nmethod should call the method *peripheral_publish_metric_int* or\n*peripheral_publish_metric_float* to send a value to MQTT/Serial. The metric\nname (3rd parameter) is used for the topic name:\n*&lt;device&gt;/&lt;peripheral&gt;/&lt;metric&gt;\n```c\n/**\n * Publish metrics to MQTT/Serial.\n */\nvoid plant_publish_metrics( uint8_t slot ) {\n peripheral_publish_metric_int( slot, peripherals[slot].val03.i, \"moisture\" );\n}\n```\n","dir":"/3.tutorial/","name":"1.reading-sensors.md","path":"3.tutorial/1.reading-sensors.md","url":"/3.tutorial/1.reading-sensors.html"},{"sort":2,"permalink":"/3.tutorial/","layout":"default","title":"Tutorial","content":"<h1 id=\"tutorial\">Tutorial</h1>\n<p>The tutorial will explain how to write your own peripherals.</p>\n<ul>\n <li><a href=\"/tutorial/reading-sensors\">Reading sensors</a></li>\n <li><a href=\"/tutorial/controlling-actuators\">Controlling actuators</a></li>\n <li><a href=\"/tutorial/using-timers\">Using timers</a></li>\n</ul>\n\n<h2 id=\"example-project\">Example project</h2>\n<p>The example used within this tutorial is based upon the\n<a href=\"https://github.com/dirkengels/iothingy-garden\">garden project</a>, which also\nserves as one of the initial use cases for the iothingy framework. The garden\nproject monitors the moisture level of one or more plants and water them when\na certain threshold is reached by enabling a pump for some time period.\nOptionally it can have a button to manually enable the pump.</p>\n\n<h2 id=\"sensors--actuators\">Sensors &amp; Actuators</h2>\n<p>The project controls watering plants automatically by reading a moisture sensor\nand when a certain threshold is reached enable a pump for a certain amount of\ntime. The peripheral <em>plant</em> consist out of one moisture level sensor and one\nactuator (relay with a pump connected to it). A device can have one or more\nplants connected to it. It contains a little bit of logic (when to enable the\npump and for how long). By having the input sensor and output actuator defined\nin the same peripheral it will also run properly when no there is network\nconnectivity.</p>\n\n<h2 id=\"variables\">Variables</h2>\n<p>The example will use 3 simple variables to store the pin numbers of the\nmoisture sensor, relay to control the pump and the button to manually enable\nthe pump. Three complex variables are used to store the value read by the\nanalog moisture sensor, the threshold when it should trigger the pump and the\ntime to keep the pump running. It also uses the two timers to keep track of\nwhen the pump was started and another one for keeping track when it was last\nwatered. The second timer causes the pump to be enabled only for a short amount\nof time before it can be re-enabled. (See the section\n<a href=\"/2.documentation/memory-usage\">Memory Usage</a> for more information about how\nmemory is used and how to optimize it for your use case).</p>\n\n<h2 id=\"usage\">Usage</h2>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">iothingy_peripherals</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/**\n   * Plant peripheral: measure moisture level and optionally control a pump.\n   * - Peripheral name\n   * - Moisture sensor pin\n   * - Pump relay pin\n   * - Threshold (0-1023)\n   * - Duration (ms)\n   */</span>\n  <span class=\"c1\">//     Name      Moisture Pump  Threshold Duration</span>\n  <span class=\"n\">plant</span><span class=\"p\">(</span> <span class=\"s\">\"plant1\"</span><span class=\"p\">,</span> <span class=\"n\">A1</span><span class=\"p\">,</span>      <span class=\"mi\">4</span><span class=\"p\">,</span>    <span class=\"mi\">400</span><span class=\"p\">,</span>      <span class=\"mi\">1000</span> <span class=\"p\">);</span>\n  <span class=\"n\">plant</span><span class=\"p\">(</span> <span class=\"s\">\"plant2\"</span><span class=\"p\">,</span> <span class=\"n\">A2</span><span class=\"p\">,</span>      <span class=\"mi\">5</span><span class=\"p\">,</span>    <span class=\"mi\">400</span><span class=\"p\">,</span>      <span class=\"mi\">2000</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre>  </div></div>\n","dir":"/3.tutorial/","name":"README.md","path":"3.tutorial/README.md","url":"/3.tutorial/"}]